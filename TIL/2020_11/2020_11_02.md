## TIL (Today I Learned)

11월 2일 (월)


### 상호 코드 리뷰
#### 학습 내용
첫번째 수업으로 상호 코드 리뷰를 하였습니다. 기죽거나, 자랑하는 것이 아니고 ‘나의 코드를 설명하고, 작성 이유에 대해 이야기 한다.’고 배웠습니다. 더불어 장점을 살피고, 칭찬과 독려를 하기 위해 노력했습니다.


#### 문제점 / 고민한 점
개선할 점을 말해주고 싶었지만, 조언하는 방식의 문제가 아니라 진짜 무엇을 개선하면 좋을지 보이지 않았던 것이 가장 고민점이었고, 다음 코드 리뷰때는 짝궁에게 많은 도움을 주고 싶다고 생각했습니다.

> 강제 언래핑의 단점
시간이 남아서 다른 분들의 코드를 보다보니, 저희가 guard let을 사용한 부분에 
강제 언래핑을 사용하신분들이 있었습니다. 어렴풋이 강제 언래핑이 좋지 않은 코딩 습관(?)이라는 것은 알았으나, 명확한 이유를 알지 못해 그 부분에 대해 찌로, 야곰과 대화를 나누고 찾아보게 되었습니다.
![](https://cdn.classum.com/course/9275-post/1604312796134/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-11-02%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.50.35.png)
> 이 부분은 과거 swift 코딩을 진행하다가 자주 터졌던(?) 부분인데, swift에서 강제 언래핑을 사용하면 안되는 (제가 겪은)가장 큰 핵심 예시라고 생각했습니다. Optional의 경우에는 값이 들어올지 안들어올지(nil) 모르는 타입임에도, 위와 같은 코드에서는 무조건 들어올 것으로 예상하고 강제 언래핑을 한 상황입니다. 그런데 실제로 제가 nil을 입력하였고, 그에 대한 대비가 없었기에 런타임 에러로 터져버린(?) 것을 확인할 수 있었습니다. (과거에 것을 재현해보았어요..) 

#### 해결 방법
“강제 언래핑을 하지않고 guard 나 if let을 사용 하면 변수에 nil을 받을수 있고, 올바르지 않은 타입의 변수를 담으려고 할때나, 잘못된 접근을 통해  예기치않은 코드오류가 발생을 예방할수있습니다.” - 짝궁님
짝궁님께서 말씀해주신 것 처럼, guard let 혹은 if let을 사용하면 이러한 경우를 막을 수 있고, 앞으로도 이 부분에 주의해서 코딩하려고 합니다.


<br/>
<br/>
<br/>


### 페어 프로그래밍
#### 학습 내용
짝 프로그래밍으로 드라이버와 내비게이터 역할을 나누어 진행하였고, 드라이버는 독단적으로 코드를 작성하지 않으며 내비게이터의 요청에만 움직였습니다. 또한 내비게이터는 명확하게 자신의 의사를 드라이버에게 요청해야 했으며 저희는 교대 시간을 10분으로 정해두고 진행하였습니다.

#### 문제점 / 고민한 점
드라이버로서의 역할을 할 때, 자의적으로 하고싶은 부분이 많았습니다. 특히 스페이스라던지 줄바꿈이라던지 이러한 간단한 것들은 시키기 전에 이미 해버리는 경우도 많았고, 내비게이터의 전체적인 그림을 알 수 없어서 조금 답답한 부분도 있었습니다.
또 내비게이터로 진행을 하려다보니, 앞서 진행된 코드에 대한 큰 그림이 제 머릿속에 없으니 이어서 나가는게 어려웠던 것 같습니다.
가장 고민했던 것은, 서로 코드를 시작하기 전에 어느 정도 어떻게 해나갈지 큰 그림은 공유를 해야하지 않는가? 였는데, 요번 페어 프로그래밍은 도전이라고 생각했기 때문에 많은 것을 공유하지 않고 바로 시작했습니다.
그러다보니 제가 내비게이터가 되었을때 짝궁에게 자꾸 질문을 하게되었고, 의견을 물어보게 되면서 코드를 짜는 시간이 조금 길어진 감이 없지 않아 있었습니다.

> 고차 함수(map)
생각보다 페어 프로그래밍이 금방 종료되어, 구구단을 주로 구성했던 for-in 구문을 고차함수로 도전하게 되었습니다. 고차함수에는 map, filter, reduce 등이 있는데, 해당 코드에서는 map이 가장 적합하다고 생각하여 도전하게 되었습니다.

> 순환 함수
기존에 구구단은 func 없이 바로 while로 돌아가는 구조였는데, 이 부분을 func를 사용하는 부분에 대해서 제이크와 고민하고 있었습니다. 마침 야곰이 순환 함수(재귀 함수)로 구현해 볼 것을 제안해주셔서 함께 고민하다가 시간이 종료되었고, 이 부분은 제가 혼자 고민하게 되었습니다!



#### 해결 방법
> 고차 함수(map)
```swift
func makeGugudan(inputNumber: Int){ 
		let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
		let result = numbers.map { print("\(inputNumber) x \($0) = \(inputNumber * $0)") }
	}
```
처음에 inputNumber을 생각하지 않고, array 2개가 아니라 1개로 진행하려고 하는 실수가 있었지만, inputNumber을 주게되니 고차 함수로 구현이 가능했습니다. 

> 순환 함수
```swift
func gugu() {
	print("구구단을 외자 : ", terminator: "")
	guard let input = readLine() else { gugu() } // return 없어도 되나?
	switch input {
case “-1”, “0”, “1” :
print("입력이 잘못되었습니다.")
case “exit” :
	return
default :
	if let num = Int(input) { makeGugudan(inputNumber: num) } 
	} 
	gugu()
}
```
순환 함수에 대한 이해는 있었지만, 실제로 예쁘게(?) 구현해 본 건 처음인 것 같습니다. 기존 while문에서 다시 처음으로 돌아가는 부분들에, 순환할 함수를 추가해주는 것만으로 순환 함수를 구현할 수 있었습니다.(이름을 짓기 귀찮았던 건 절.대. 아닐 걸..?)


<br/>
<br/>
<br/>


### 참고 링크
https://oaksong.github.io/2018/01/20/higher-order-functions // 고차함수
https://pjh3749.tistory.com/247 // 페어프로그래밍
https://emongfactory.tistory.com/106 // 강제 언래핑
https://www.youtube.com/watch?v=RxScvfe1dyU // 강제 언래핑


<br/>
<br/>
<br/>

#### 다른분들 TIL 참고하여 수정해 본 코드
```swift
import Foundation
 
func makeGugu(input: Int){
    _ = Array(1...9).map { print("\(input) x \($0) = \(input * $0)") }
}
 
func gugu() {
  print("구구단을 외자 : ", terminator: "")
 
 if let input = readLine() {
   switch input {
     case "-1", "0", "1" :
        print("입력이 잘못되었습니다.")
     case "exit" :
        return
     default :
        if let num = Int(input) { makeGugu(input: num) }
   }
 } 
  gugu()
}
 
gugu()
```

<br/>
첫날 작성했던 google docs링크

<https://docs.google.com/document/d/15o2rf5_-WvHpZehB7uo_WfQh_DJi7XGYKdLReyVJ9Ro/edit?usp=sharing>
