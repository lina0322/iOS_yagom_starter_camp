## TIL (Today I Learned)
12월 10일 (목)
> 제가 이해한 대로 작성한 내용이다 보니, 정확한 정보가 아닐 수 있습니다.   
고쳐야 할 부분이 있다면, 편하게 얘기해 주시면 감사하겠습니다.🙏🏻

<br/>

### 알고리즘
문제 해결을 위한 절차/방법  
어떠한 문제를 해결하기 위한 여러 동작들의 모음  
일을 처리하는 순서/방법  
> ex) 정렬, 탐색(선형 탐색, 이진 탐색-이진 트리), 재귀 등  

#### 정렬
데이터의 구조, 양에 따라서 속도가 달라지기 때문에 항상 어떤 정렬이 우위라고 말할 수는 없고,  
필요에 따라서 선택하고, 섞어서 사용할 수도 있음.  

1. 선택정렬
주어진 리스트 중에 최소값을 찾는다 -> 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)) -> 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다  

2. 버블정렬
오름차순으로 정렬하는 거품정렬의 과정은 다음과 같다.  
[55 07] 78 12 42  []은 sort  
07 “55 78” 12 42  “”은 pass  
07 55 [78 12] 42   
07 55 12 [78 42]  
“07 55” 12 42 78  두 번째 패스(pass)  
07 [55 12] 42 78  
07 12 [55 42] 78  
“07 12” 42 55 78  세 번째 패스(pass)  
07 “12 42” 55 78  네 번째 패스(pass)  
07 12 “42 55” 78  다섯 번째 패스(pass)  
07 12 42 55 78  정렬 끝  

3. 삽입정렬
31 25 12 22 11 처음 상태.  
31 [25] 12 22 11 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.  
<25> 31 [12] 22 11 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.   
<12> 25 31 [22] 11 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.  
12 <22> 25 31 [11] 마지막 원소를 부분 리스트에서 적절한 위치에 삽입한다.  
<11> 12 22 25 31 종료.  

4. 병합정렬(합병 정렬)
https://commons.wikimedia.org/wiki/File:Merge-sort-example-300px.gif

5. 퀵정렬
피벗은 p, 리스트 왼쪽 끝과 오른쪽 끝에서 시작한 인덱스들을 i,j라고 하자.  
5 - 3 - 7 - 6 - 2 - 1 - 4  
                        p  
리스트 왼쪽에 있는 i 위치의 값이 피벗 값보다 크고, 오른쪽에 있는 j 위치의 값은 피벗 값보다 작으므로 둘을 교환한다.  
5 - 3 - 7 - 6 - 2 - 1 - 4   
i                   j   p   
1 - 3 - 7 - 6 - 2 - 5 - 4   
i                   j   p   
j 위치의 값이 피벗 값보다 작지만, i 위치의 값도 피벗값보다 작으므로 교환하지 않는다.  
1 - 3 - 7 - 6 - 2 - 5 - 4   
    i           j       p   
i위치를 피벗 값보다 큰 값이 나올 때까지 진행해 j 위치의 값과 교환한다.  
1 - 3 - 7 - 6 - 2 - 5 - 4   
        i       j       p   
1 - 3 - 2 - 6 - 7 - 5 - 4   
        i       j       p   
i위치가 j 위치보다 커지면, i 위치의 값과 피벗 값을 교환한다.  
1 - 3 - 2 - 6 - 7 - 5 - 4   
                        p   
1 - 3 - 2 - 4 - 7 - 5 - 6   
            p               
피벗 값 좌우의 리스트에 대해 각각 퀵 정렬을 재귀적으로 수행한다.  
1 - 3 - 2       7 - 5 - 6  
1 - 2 - 3       5 - 6 - 7  
완성된 리스트는 다음과 같다.  
1 - 2 - 3 - 4 - 5 - 6 - 7  


#### 시간 복잡도
알고리즘이 실행되는데 소요되는 시간 분석  
점근 표기법(대문자 O 표기법, big O 표기법)  
> ex) 선택정렬,버블정렬,삽입정렬-O(n^2) / 병합정렬,퀵정렬-O(nlogn) 
ex) 선형 탐색 O(n), 이진 탐색 - O(logn)


### 자료구조
자료를 효율적으로 이용할 수 있는 방법론  
데이터를 구조적으로 표현하는 방식  
각각의 장단점이 있기 때문에 항상 옳거나, 틀린 자료구조가 있는 것이 아님  
> ex) 테트리스
적절한 모양의 블럭(자료구조)을 요리조리 돌리고 옮겨(알고리즘) 게임을 클리어
ex) 여행 가방
효율적으로 물건들의 부피를 줄이고(자료구조), 꺼낼 순서에 맞게(알고리즘) 차곡차곡 정리해 넣으면 알차게 넣을 수 있음

#### 원시구조
정수, 실수, 문자 …

#### 선형구조
1. 배열 
여러가지 데이터를 하나의 줄 모양으로 표현    
개수, 크기가 정해져있음  
가장 간단하고, 가장 빠른 자료구조(몇번째 칸인지 정해져 있어서)  
단, 배열은 칸 수가 정해져있어서 메모리에 그 만큼 항상 자리를 차지함  

2. 연결 리스트
연결 리스트들은 데이터를 넣는 곳과, 다른 칸의 위치 주소를 넣는 곳으로 이루어져있음.   
추가와 삭제가 자유로움  
	단, 다음 칸이 어딘지는 계속 물어서 가야함. 100번째 칸이라면 100번 물어야함…  
값도 가지고 있고, 다음 칸의 주소도 가지고있어서(혹은 앞의 칸의 주소까지도…) 메모리를 더 많이 차지할수도 있음.  
- 단순 연결 리스트: 다음 칸의 위치 주소만 알고 있음
- 이중 연결 리스트: 이전 칸과 다음 칸의 위치주소를 모두 알고있음
- 원형 연결 리스트: 맨 마지막 칸의 다음 주소가 맨 앞칸의 주소임

3. 스택
추상적인 자료구조(구현체라기보단 개념임)  
> FILO ex) 브라우저에서 뒤로가기, 앞으로가기 버튼!  

4. 큐
추상적인 자료구조(구현체라기보단 개념임)
> FIFO ex) 대기열

5. 덱
double eneed queue  
큐와 스택이 합쳐진 구조  

#### 비선형구조
1. 트리
루트(뿌리)로부터 브랜치로 뻗어나가는 모양  
선이 겹쳐지지 않음  
ex) 가계도  

2. 그래프
서로 연결된 그물망  
시작과 끝이라는 것이 없음  
ex) 페이스북의 그래프 인맥관계  

</br>

---

#### 참고문헌
정렬 관련들은 모두 위키백과
나머지는 야곰의 재미난 컴퓨터 기초 : 2편 자료구조와 알고리즘에 대하여

[다음 TIL 보기](https://github.com/lina0322/yagom_iOS_camp/blob/main/TIL/2020_12/2020_12_14.md)
